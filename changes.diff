diff --git a/bible-scraper.py b/bible-scraper.py
--- a/bible-scraper.py
+++ b/bible-scraper.py
@@ -223,6 +223,71 @@
     return cleaned.strip(",;:. ").strip()
 
 
+def _backfill_bare_function_words(text: str) -> str:
+    """
+    If answer removal leaves dangling function words (e.g., 'the of', 'in the', 'at'),
+    backfill with a generic blank to preserve solvable structure.
+    """
+    if not text:
+        return text
+    # Common determiners/prepositions that often dangle after answer removal.
+    patterns = [
+        r"\b(of|in|at|to|from|for|with|by)\s*(?=[,.;:]|\Z)",       # 'of' → 'of ___'
+        r"\b(the|a|an)\s*(?=[,.;:]|\Z)",                           # 'the' → 'the ___'
+        r"\b(of|in|at|to|from|for|with|by)\s+the\s*(?=[,.;:]|\Z)", # 'of the' → 'of the ___'
+        r"\bthe\s+of\b",                                           # 'the of' → 'the ___ of' is awkward; simpler → 'the ___'
+    ]
+    for pat in patterns:
+        text = re.sub(pat, lambda m: m.group(0).rstrip() + " ___", text, flags=re.IGNORECASE)
+    # Specific repair: 'the of ___' → 'the ___'
+    text = re.sub(r"\bthe\s+of\s+___\b", "the ___", text, flags=re.IGNORECASE)
+    # If we created double blanks, collapse to one.
+    text = re.sub(r"(___)\s+(___)", r"\1", text)
+    return text
+
+
+def _normalize_grammar(text: str) -> str:
+    """
+    Lightweight grammar/polish pass for clue fragments produced by template assembly.
+    Intentional minimalism to avoid hallucinating content.
+    """
+    if not text:
+        return text
+    t = text
+    # Remove noisy 'Now' tokens and redundant commas/spaces.
+    t = re.sub(r"\b[Nn]ow\b", "", t)
+    t = re.sub(r"\s{2,}", " ", t)
+    t = re.sub(r"\s+([,.;:])", r"\1", t)
+    t = re.sub(r"([,.;:])([^\s])", r"\1 \2", t)
+    # Common agreement fixes in first-person plural phrases that show up in summaries.
+    t = re.sub(r"\bWe\s+sees\b", "We see", t)
+    t = re.sub(r"\bWe\s+knows\b", "We know", t)
+    t = re.sub(r"\bThey\s+sees\b", "They see", t)
+    t = re.sub(r"\bThey\s+knows\b", "They know", t)
+    # Remove duplicate prepositions (e.g., 'in in', 'of of').
+    t = re.sub(r"\b(\w+)\s+\1\b", r"\1", t, flags=re.IGNORECASE)
+    # Clean odd artifacts like "the ,", "the ."
+    t = re.sub(r"\b(the|a|an)\s+([,.;:])", r"\2", t, flags=re.IGNORECASE)
+    # Ensure we didn't end on a dangling preposition/determiner without a blank.
+    t = _backfill_bare_function_words(t)
+    # Final whitespace tidy.
+    t = re.sub(r"\s{2,}", " ", t).strip()
+    return t
+
+
+def _enforce_category_opening(category: str, body: str, *,
+                              role_phrase: Optional[str] = None,
+                              object_hypernym: str = "object") -> str:
+    """
+    Force consistent, helpful openings per category with minimal text surgery.
+    """
+    raw = body.strip()
+    if category == CATEGORY_PERSON:
+        lead = (role_phrase or "Figure")
+        return f"{lead} who {raw}"
+    if category == CATEGORY_PLACE:
+        # Avoid double 'where'
+        return "Place where " + re.sub(r"^\s*where\s+", "", raw, flags=re.IGNORECASE)
+    if category == CATEGORY_OBJECT:
+        # Guarantee "This <something> ..." for solvability
+        if not re.match(r"^\s*this\b", raw, flags=re.IGNORECASE):
+            raw = f"{object_hypernym} {raw}"
+        return "This " + raw.lstrip()
+    # Theology/Other: keep body but repaired elsewhere
+    return raw
+
+
 def normalize_upper(text: str) -> str:
     return NON_ALPHA_RE.sub("", text.upper()) if text else ""
 
@@ -349,6 +414,7 @@
     snippet = re.sub(r"\s+", " ", snippet)
     snippet = re.sub(r"\d+:\d+", "", snippet)
     snippet = snippet.strip(" ,.;:-")
+    snippet = _backfill_bare_function_words(snippet)
     return snippet
 
 
@@ -386,9 +452,12 @@
     return snippet
 
 
 def finalize_clue(text: str) -> str:
-    cleaned = re.sub(r"\s+", " ", text).strip(" ;,")
+    # Repair dangling function words and light grammar before final casing/punct.
+    repaired = _normalize_grammar(_backfill_bare_function_words(text))
+    cleaned = re.sub(r"\s+", " ", repaired).strip(" ;,")
     if not cleaned:
         return ""
     if cleaned[-1] not in ".?!":
         cleaned = f"{cleaned}."
@@ -622,22 +691,34 @@
     role = infer_role(candidate.word, context_words, payload.vocab)
-    role_phrase = role.capitalize() if role else "Figure"
+    # Avoid unhelpful "Man/Woman who ..." — prefer 'Figure' when role is generic.
+    role_phrase = (role.capitalize() if role and role.lower() not in {"man", "woman"} else "Figure")
     verb_phrases = candidate.context_phrases or (extract_verb_phrases(token, candidate.word) if token else [])
     hints = extract_hint_phrases(context_words)
     clue_body = ""
     if verb_phrases:
         clue_body = verb_phrases[0]
         if hints and hints[0] not in clue_body:
             clue_body = f"{clue_body}, {hints[0]}"
     else:
         summary = summarize_context(token, candidate.word, CATEGORY_PERSON)
         if summary:
             clue_body = summary
     if not clue_body:
         clue_body = "plays a key role in this chapter"
-    clue = f"{role_phrase} who {clue_body}"
-    clue = remove_answer_from_clue(clue, candidate.word)
-    clue = finalize_clue(clue)
+    # Enforce category opening and repair after answer removal
+    clue_raw = _enforce_category_opening(CATEGORY_PERSON, clue_body, role_phrase=role_phrase)
+    clue = remove_answer_from_clue(clue_raw, candidate.word)
+    clue = finalize_clue(clue)
     return ensure_unique_structure(clue, token, candidate, existing_signatures)
 
 def build_place_description(token: Any, answer: str) -> str:
@@ -690,12 +771,15 @@
     if not description:
         description = "is a location highlighted in this chapter"
-    clue = f"Where {description}"
-    clue = remove_answer_from_clue(clue, candidate.word)
-    clue = finalize_clue(clue)
+    clue_raw = _enforce_category_opening(CATEGORY_PLACE, description)
+    clue = remove_answer_from_clue(clue_raw, candidate.word)
+    clue = finalize_clue(clue)
     return ensure_unique_structure(clue, token, candidate, existing_signatures)
 
 
 def build_object_description(token: Any, answer: str) -> str:
@@ -742,11 +826,13 @@
     if not description:
         description = "object highlighted in this passage"
-    clue = remove_answer_from_clue(description, candidate.word)
-    if clue and not clue.lower().startswith(("this", "these", "it", "symbol", "item")):
-        clue = f"This {clue}" if not clue.lower().startswith("this ") else clue
-    clue = finalize_clue(clue)
+    clue_raw = _enforce_category_opening(CATEGORY_OBJECT, description, object_hypernym="object")
+    clue = remove_answer_from_clue(clue_raw, candidate.word)
+    clue = finalize_clue(clue)
     return ensure_unique_structure(clue, token, candidate, existing_signatures)
 
@@ -792,10 +878,12 @@
     if not description:
         description = "key theme in this chapter"
-    clue = f"Concept {description}"
-    clue = remove_answer_from_clue(clue, candidate.word)
-    clue = finalize_clue(clue)
+    clue_raw = f"Concept {description}"
+    clue = remove_answer_from_clue(clue_raw, candidate.word)
+    clue = finalize_clue(clue)
     return ensure_unique_structure(clue, token, candidate, existing_signatures)
 
@@ -809,9 +897,11 @@
     if not summary:
         summary = "mentioned in this chapter"
-    clue = remove_answer_from_clue(summary, candidate.word)
-    clue = finalize_clue(clue)
+    clue_raw = summary
+    clue = remove_answer_from_clue(clue_raw, candidate.word)
+    clue = finalize_clue(clue)
     return ensure_unique_structure(clue, token, candidate, existing_signatures)
